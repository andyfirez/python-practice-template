# Создание приложения для управления задачами (Todo App)

## Задание

Создать простое приложение для управления задачами с использованием архитектуры репозиториев. Приложение должно работать с JSON файлами для хранения данных о задачах, категориях и статусах.

## Почему выбрана такая архитектура?

### Чистая архитектура (Clean Architecture)

Мы используем принципы чистой архитектуры, которые помогают создавать понятный, тестируемый и расширяемый код:

1. **Разделение ответственности** - каждый класс отвечает за свою конкретную задачу
2. **Независимость от внешних зависимостей** - бизнес-логика не зависит от способа хранения данных
3. **Легкость тестирования** - можно легко заменить реальные репозитории на моки
4. **Простота понимания** - код структурирован логически

### Почему разделение на модели и репозитории?

**Модели (Models)** - это структуры данных, которые описывают сущности нашего приложения:
- `Task` - описывает задачу со всеми её свойствами
- `Category` - описывает категорию задач
- `Status` - описывает статус задачи

**Репозитории (Repositories)** - это классы, которые отвечают за работу с данными:
- Загрузка данных из файлов
- Сохранение данных в файлы
- Поиск и фильтрация данных
- Добавление, обновление, удаление записей

Такое разделение позволяет:
- Легко изменить способ хранения данных (JSON → база данных → облачное хранилище)
- Переиспользовать модели в разных частях приложения
- Тестировать бизнес-логику отдельно от логики работы с данными

### Почему для каждой модели свой репозиторий?

Каждая модель может иметь специфические операции:
- `TaskRepository` - поиск по категории, статусу, просроченные задачи
- `CategoryRepository` - простые CRUD операции
- `StatusRepository` - простые CRUD операции

Это позволяет:
- Добавлять специфичные методы для каждой модели
- Изолировать логику работы с разными типами данных
- Легко расширять функциональность

### Почему удобно наследование от BaseRepository?

`BaseRepository` содержит общие операции, которые нужны всем репозиториям:
- `add()` - добавление записи
- `get()` - получение записи по ID
- `get_all()` - получение всех записей
- `update()` - обновление записи
- `delete()` - удаление записи
- `_load()` и `_save()` - работа с файлами

Наследование позволяет:
- Избежать дублирования кода
- Добавлять специфичные методы в дочерних классах
- Легко поддерживать единообразие в работе с данными

## Требования к реализации

### 1. Модели данных (Models) - УЖЕ РЕАЛИЗОВАНЫ

**Класс `Category`** (файл `models/category.py`):
- `id: int` - уникальный идентификатор категории
- `name: str` - название категории (от 2 до 50 символов)

**Класс `Status`** (файл `models/status.py`):
- `id: int` - уникальный идентификатор статуса
- `name: str` - название статуса

**Класс `Task`** (файл `models/task.py`):
- `id: int` - уникальный идентификатор задачи
- `title: str` - заголовок задачи (от 3 до 100 символов)
- `description: Optional[str]` - описание задачи (опционально)
- `created_at: datetime` - дата создания (по умолчанию текущее время)
- `category_id: int` - ID категории
- `status_id: int` - ID статуса
- `is_done: Optional[bool]` - выполнена ли задача (по умолчанию False)
- `deadline: Optional[datetime]` - дедлайн (опционально)
- `repeat_every: Optional[str]` - повторение ("day", "week", "month", опционально)

### 2. Базовый репозиторий (Base Repository) - НУЖНО РЕАЛИЗОВАТЬ

**Класс `BaseRepository`** (файл `repositories/base_repository.py`):
- `__init__(self, file_path: str, model: Type[T])` - инициализация с путем к файлу и моделью
- `add(self, item: T) -> T` - добавление элемента
- `get(self, id_: int) -> Optional[T]` - получение элемента по ID
- `get_all(self) -> List[T]` - получение всех элементов
- `update(self, id_: int, **kwargs) -> bool` - обновление элемента
- `delete(self, id_: int) -> bool` - удаление элемента
- `_load(self) -> None` - загрузка данных из файла
- `_save(self) -> None` - сохранение данных в файл

### 3. Специализированные репозитории - НУЖНО РЕАЛИЗОВАТЬ

**Класс `CategoryRepository`** (файл `repositories/category_repository.py`):
- Наследует от `BaseRepository[Category]`
- `__init__(self, file_path: str)` - инициализация с путем к файлу
- `get_by_name(self, name: str) -> Optional[Category]` - поиск категории по имени

**Класс `StatusRepository`** (файл `repositories/status_repository.py`):
- Наследует от `BaseRepository[Status]`
- `__init__(self, file_path: str)` - инициализация с путем к файлу
- `_init_default_statuses(self) -> None` - инициализация статусов по умолчанию
- `is_valid_status(self, status_id: int) -> bool` - проверка валидности статуса

**Класс `TaskRepository`** (файл `repositories/task_repository.py`):
- Наследует от `BaseRepository[Task]`
- `__init__(self, file_path: str)` - инициализация с путем к файлу
- `get_by_category(self, category_id: int) -> List[Task]` - получение задач по категории
- `get_by_status(self, status_id: int) -> List[Task]` - получение задач по статусу

### 4. Основной класс приложения - НУЖНО РЕАЛИЗОВАТЬ

**Класс `TodoApp`** (файл `todo_app.py`):
- `__init__(self, data_dir: str)` - инициализация с директорией данных
- `add_task(self, title: str, category_id: int, status_id: int, **kwargs) -> Task` - добавление задачи с проверкой существования категории и статуса
- `mark_task_done(self, task_id: int) -> bool` - отметить задачу как выполненную
- `get_overdue_tasks(self) -> List[Task]` - получить просроченные задачи

**Доступ к репозиториям:**
После инициализации `TodoApp` вы можете работать с репозиториями напрямую:
- `app.task_repo` - репозиторий задач
- `app.category_repo` - репозиторий категорий  
- `app.status_repo` - репозиторий статусов

### 5. Дополнительные функции - НУЖНО РЕАЛИЗОВАТЬ

- `load_sample_data(app: TodoApp) -> None` - загрузка примерных данных в JSON файлы
- `print_task(task: Task) -> None` - вывод информации о задаче
- `print_tasks(tasks: List[Task]) -> None` - вывод списка задач

## Входные данные

Пример содержимого файлов:

`categories.json`:
```json
{
    "1": {"id": 1, "name": "Работа"},
    "2": {"id": 2, "name": "Личное"},
    "3": {"id": 3, "name": "Учеба"}
}
```

`statuses.json`:
```json
{
    "1": {"id": 1, "name": "Новая"},
    "2": {"id": 2, "name": "В работе"},
    "3": {"id": 3, "name": "Завершена"}
}
```

`tasks.json`:
```json
{
    "1": {
        "id": 1,
        "title": "Изучить Python",
        "description": "Изучить основы языка Python",
        "created_at": "2024-01-15T10:00:00",
        "category_id": 3,
        "status_id": 1,
        "is_done": false,
        "deadline": "2024-02-01T23:59:59",
        "repeat_every": null
    },
    "2": {
        "id": 2,
        "title": "Сделать покупки",
        "description": "Купить продукты на неделю",
        "created_at": "2024-01-15T11:00:00",
        "category_id": 2,
        "status_id": 2,
        "is_done": false,
        "deadline": null,
        "repeat_every": "week"
    }
}
```

## Пример использования

```python
# Создание приложения
app = TodoApp("data")

# Работа с репозиториями напрямую
all_tasks = app.task_repo.get_all()
work_tasks = app.task_repo.get_by_category(1)
new_tasks = app.task_repo.get_by_status(1)

# Высокоуровневые операции
task = app.add_task(
    title="Новая задача",
    category_id=1,
    status_id=1,
    description="Описание задачи",
    deadline=datetime(2024, 2, 1)
)

# Отметить задачу как выполненную
app.mark_task_done(1)

# Получить просроченные задачи
overdue = app.get_overdue_tasks()

# Работа с категориями и статусами
categories = app.category_repo.get_all()
statuses = app.status_repo.get_all()
```

## Преимущества такой архитектуры

### Для начинающих разработчиков:

1. **Понятная структура** - каждый файл имеет четкое назначение
2. **Легкость отладки** - проблемы локализованы в конкретных классах
3. **Возможность роста** - можно постепенно добавлять новую функциональность
4. **Переиспользование кода** - общие операции вынесены в базовый класс
5. **Прямой доступ к репозиториям** - можно работать с данными напрямую

### Для реальных проектов:

1. **Масштабируемость** - легко добавлять новые модели и репозитории
2. **Гибкость** - можно легко изменить способ хранения данных
3. **Тестируемость** - каждый компонент можно тестировать отдельно
4. **Поддерживаемость** - изменения в одном месте не влияют на другие части

## Как запустить тесты

После выполнения задания проверьте своё решение с помощью автотестов:

```sh
python -m pytest tests/classes/todo_app/
```

Для запуска конкретных тестов:

```sh
# Тесты интеграции
python -m pytest tests/classes/todo_app/test_integration.py

# Тесты репозиториев
python -m pytest tests/classes/todo_app/repositories/
```

Убедитесь, что виртуальное окружение активировано перед запуском тестов. 